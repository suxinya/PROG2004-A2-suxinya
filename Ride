import java.util.Iterator;
import java.util.LinkedList;
import java.util.Queue;
public class Ride implements RideInterface {
    // private variable
    private String rideId;       // Unique ID of the facility
    private String rideName;     // Facility Name
    private int maxRider;        // Maximum passenger capacity per trip
    private Employee operator;   // operator
    private int numOfCycles;     // Number of cycles already run

    // New: Part 3 Waiting Queue (using LinkedList to implement Queue interface, FIFO feature)
    private Queue<Visitor> waitingLine;
    // New: Part 4A ride records (using LinkedList, supporting Iterator traversal)
    private LinkedList<Visitor> rideHistory;

    // 1. Default constructor
    public Ride() {
        this.numOfCycles = 0; // The default number of cycles is 0 (initialization state)
        this.waitingLine = new LinkedList<>(); // Initialize queue
        this.rideHistory = new LinkedList<>(); // Initialize ride record
    }

    // 2. Constructor with parameters: Initialize all core properties
    public Ride(String rideId, String rideName, int maxRider, Employee operator) {
        this.rideId = rideId;
        this.rideName = rideName;
        this.maxRider = maxRider;
        this.operator = operator;
        this.numOfCycles = 0; // Explicit initialization to avoid forgetting
        this.waitingLine = new LinkedList<>();
        this.rideHistory = new LinkedList<>();
    }

    // 3. Getter/Setter
    public String getRideId() {
        return rideId;
    }

    public void setRideId(String rideId) {
        this.rideId = rideId;
    }

    public String getRideName() {
        return rideName;
    }

    public void setRideName(String rideName) {
        this.rideName = rideName;
    }

    public int getMaxRider() {
        return maxRider;
    }

    public void setMaxRider(int maxRider) {
        // Data verification: At least one passenger capacity per trip
        if (maxRider >= 1) {
            this.maxRider = maxRider;
        } else {
            System.out.println("Error: Single passenger capacity cannot be less than 1 person!");
        }
    }

    public Employee getOperator() {
        return operator;
    }

    public void setOperator(Employee operator) {
        this.operator = operator;
    }

    public int getNumOfCycles() {
        return numOfCycles;
    }

    // NumOfCycles can only be increased through runtime cycles and does not provide setters (encapsulation: control modification logic)
    public void incrementCycles() {
        this.numOfCycles++;
    }

    // Part 3: Add tourists to the queue

    @Override
    public boolean addVisitorToQueue(Visitor visitor) {
        if (visitor != null) {
            waitingLine.offer(visitor); // Queue's offer(): Add element
            System.out.println("Successfully added tourist to[" + rideName + "]Queue:" + visitor.getName());
            return true;
        } else {
            System.out.println("Error: Unable to add empty tourists to the queue!");
            return false;
        }
    }

    @Override
    public Visitor removeVisitorFromQueue() {
        if (!waitingLine.isEmpty()) {
            Visitor removedVisitor = waitingLine.poll(); // Poll() of Queue: Remove and return the leader of the queue
            System.out.println("Remove tourists from queue [" + rideName + "]:" + removedVisitor.getName());
            return removedVisitor;
        } else {
            System.out.println("Error: [" + rideName + "] queue is empty, unable to remove guest!");
            return null;
        }
    }

    @Override
    public void printQueue() {
        System.out.println("\n=== [" + rideName + "] Waiting for queue information ===");
        if (waitingLine.isEmpty()) {
            System.out.println("There are currently no tourists waiting in the queue.");
            return;
        }
        // traverse the queue
        int index = 1;
        for (Visitor visitor : waitingLine) {
            System.out.println("Queue position" + index + "：" + visitor);
            index++;
        }
        System.out.println("Total number of people in the queue:" + waitingLine.size());
    }

    // Part 4A: Add tourist to ride history
    @Override
    public boolean addVisitorToHistory(Visitor visitor) {
        if (visitor != null) {
            rideHistory.add(visitor); // LinkedList的add()：添加到末尾
            System.out.println("Successfully added tourist to [" + rideName + "] ride history:" + visitor.getName());
            return true;
        } else {
            System.out.println("Error: Unable to add empty tourists to the ride record!");
            return false;
        }
    }

    // Part 4A: Check if the tourist is in the ride record
    @Override
    public boolean checkVisitorFromHistory(Visitor visitor) {
        if (visitor == null) {
            System.out.println("Error: Unable to check empty tourists!");
            return false;
        }
        // Traverse ride records
        Iterator<Visitor> iterator = rideHistory.iterator();
        while (iterator.hasNext()) {
            Visitor historyVisitor = iterator.next();
            // Determine whether it is the same tourist through visitorId
            if (historyVisitor.getVisitorId().equals(visitor.getVisitorId())) {
                System.out.println("Tourist [" + visitor. getName() + "] exists in the [" + rideName + "] ride record.");
                return true;
            }
        }
        System.out.println("Tourist [" + visitor. getName() + "] does not exist in the [" + rideName + "] ride record.");
        return false;
    }

    // Part 4A: Number of Returned Passengers Recorded
    @Override
    public int numberOfVisitors() {
        int count = rideHistory.size();
        System.out.println("[" + rideName + "]Total number of passengers recorded:" + count);
        return count;
    }

    // Part 4A: Printing ride records
    @Override
    public void printRideHistory() {
        System.out.println("\n=== [" + rideName + "] Ride record ===");
        if (rideHistory.isEmpty()) {
            System.out.println("The ride record is empty.");
            return;
        }
        // Traverse with Iterator
        Iterator<Visitor> iterator = rideHistory.iterator();
        int index = 1;
        while (iterator.hasNext()) {
            Visitor visitor = iterator.next();
            System.out.println("record" + index + "：" + visitor);
            index++;
        }
        System.out.println("Total number of passengers recorded:" + rideHistory.size());
    }

    // Implementing Part 4B: Sorting Method for Ride Records
    public void sortRideHistory(VisitorComparator comparator) {
        if (rideHistory.isEmpty()) {
            System.out.println("Error:[" + rideName + "]The ride record is empty and cannot be sorted!");
            return;
        }
        if (comparator == null) {
            System.out.println("Error:The sorting rule cannot be empty!");
            return;
        }
        // Call Collections. sort: Need to import java. til.Clusters
        java.util.Collections.sort(rideHistory, comparator);
        System.out.println("Successfully sorted the ride records of [" + rideName + "]!");
    }

    // RunOneCycle() for Part 5: still occupying space
    @Override
    public void runOneCycle() {
    }

    // Original toString(): Add the size of the queue and records
    @Override
    public String toString() {
        return "Ride{" +
                "rideId='" + rideId + '\'' +
                ", rideName='" + rideName + '\'' +
                ", maxRider=" + maxRider +
                ", operator=" + operator +
                ", numOfCycles=" + numOfCycles +
                ", waitingQueueSize=" + waitingLine.size() +
                ", numberOfPassengersRecorded=" + rideHistory.size() +
                '}';
    }

    public LinkedList<Visitor> getRideHistory() {
        return rideHistory;
    }
}
