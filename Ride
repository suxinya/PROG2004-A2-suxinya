import java.io.*;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Queue;

public class Ride implements RideInterface {
    // private variable
    private String rideId;       // Unique ID of the facility
    private String rideName;     // Facility Name
    private int maxRider;        // Maximum passenger capacity per trip
    private Employee operator;   // operator
    private int numOfCycles;     // Number of cycles already run

    // New: Part 3 Waiting Queue (using LinkedList to implement Queue interface, FIFO feature)
    private Queue<Visitor> waitingLine;
    // New: Part 4A ride records (using LinkedList, supporting Iterator traversal)
    private LinkedList<Visitor> rideHistory;

    // 1. Default constructor
    public Ride() {
        this.numOfCycles = 0; // The default number of cycles is 0 (initialization state)
        this.waitingLine = new LinkedList<>(); // Initialize queue
        this.rideHistory = new LinkedList<>(); // Initialize ride record
    }

    // 2. Constructor with parameters: Initialize all core properties
    public Ride(String rideId, String rideName, int maxRider, Employee operator) {
        this.rideId = rideId;
        this.rideName = rideName;
        this.maxRider = maxRider;
        this.operator = operator;
        this.numOfCycles = 0; // Explicit initialization to avoid forgetting
        this.waitingLine = new LinkedList<>();
        this.rideHistory = new LinkedList<>();
    }

    // 3. Getter/Setter
    public String getRideId() {
        return rideId;
    }

    public void setRideId(String rideId) {
        this.rideId = rideId;
    }

    public String getRideName() {
        return rideName;
    }

    public void setRideName(String rideName) {
        this.rideName = rideName;
    }

    public int getMaxRider() {
        return maxRider;
    }

    public void setMaxRider(int maxRider) {
        // Data verification: At least one passenger capacity per trip
        if (maxRider >= 1) {
            this.maxRider = maxRider;
        } else {
            System.out.println("Error: Single passenger capacity cannot be less than 1 person!");
        }
    }

    public Employee getOperator() {
        return operator;
    }

    public void setOperator(Employee operator) {
        this.operator = operator;
    }

    public int getNumOfCycles() {
        return numOfCycles;
    }

    // NumOfCycles can only be increased through runtime cycles and does not provide setters (encapsulation: control modification logic)
    public void incrementCycles() {
        this.numOfCycles++;
    }

    // Part 3: Add tourists to the queue

    @Override
    public boolean addVisitorToQueue(Visitor visitor) {
        if (visitor != null) {
            waitingLine.offer(visitor); // Queue's offer(): Add element
            System.out.println("Successfully added tourist to[" + rideName + "]Queue:" + visitor.getName());
            return true;
        } else {
            System.out.println("Error: Unable to add empty tourists to the queue!");
            return false;
        }
    }

    @Override
    public Visitor removeVisitorFromQueue() {
        if (!waitingLine.isEmpty()) {
            Visitor removedVisitor = waitingLine.poll(); // Poll() of Queue: Remove and return the leader of the queue
            System.out.println("Remove tourists from queue [" + rideName + "]:" + removedVisitor.getName());
            return removedVisitor;
        } else {
            System.out.println("Error: [" + rideName + "] queue is empty, unable to remove guest!");
            return null;
        }
    }

    @Override
    public void printQueue() {
        System.out.println("\n=== [" + rideName + "] Waiting for queue information ===");
        if (waitingLine.isEmpty()) {
            System.out.println("There are currently no tourists waiting in the queue.");
            return;
        }
        // traverse the queue
        int index = 1;
        for (Visitor visitor : waitingLine) {
            System.out.println("Queue position" + index + "：" + visitor);
            index++;
        }
        System.out.println("Total number of people in the queue:" + waitingLine.size());
    }

    // Part 4A: Add tourist to ride history
    @Override
    public boolean addVisitorToHistory(Visitor visitor) {
        if (visitor != null) {
            rideHistory.add(visitor); // LinkedList的add()：添加到末尾
            System.out.println("Successfully added tourist to [" + rideName + "] ride history:" + visitor.getName());
            return true;
        } else {
            System.out.println("Error: Unable to add empty tourists to the ride record!");
            return false;
        }
    }

    // Part 4A: Check if the tourist is in the ride record
    @Override
    public boolean checkVisitorFromHistory(Visitor visitor) {
        if (visitor == null) {
            System.out.println("Error: Unable to check empty tourists!");
            return false;
        }
        // Traverse ride records
        Iterator<Visitor> iterator = rideHistory.iterator();
        while (iterator.hasNext()) {
            Visitor historyVisitor = iterator.next();
            // Determine whether it is the same tourist through visitorId
            if (historyVisitor.getVisitorId().equals(visitor.getVisitorId())) {
                System.out.println("Tourist [" + visitor. getName() + "] exists in the [" + rideName + "] ride record.");
                return true;
            }
        }
        System.out.println("Tourist [" + visitor. getName() + "] does not exist in the [" + rideName + "] ride record.");
        return false;
    }

    // Part 4A: Number of Returned Passengers Recorded
    @Override
    public int numberOfVisitors() {
        int count = rideHistory.size();
        System.out.println("[" + rideName + "]Total number of passengers recorded:" + count);
        return count;
    }

    // Part 4A: Printing ride records
    @Override
    public void printRideHistory() {
        System.out.println("\n=== [" + rideName + "] Ride record ===");
        if (rideHistory.isEmpty()) {
            System.out.println("The ride record is empty.");
            return;
        }
        // Traverse with Iterator
        Iterator<Visitor> iterator = rideHistory.iterator();
        int index = 1;
        while (iterator.hasNext()) {
            Visitor visitor = iterator.next();
            System.out.println("record" + index + "：" + visitor);
            index++;
        }
        System.out.println("Total number of passengers recorded:" + rideHistory.size());
    }

    // Implementing Part 4B: Sorting Method for Ride Records
    public void sortRideHistory(VisitorComparator comparator) {
        if (rideHistory.isEmpty()) {
            System.out.println("Error:[" + rideName + "]The ride record is empty and cannot be sorted!");
            return;
        }
        if (comparator == null) {
            System.out.println("Error:The sorting rule cannot be empty!");
            return;
        }
        // Call Collections. sort: Need to import java. til.Clusters
        java.util.Collections.sort(rideHistory, comparator);
        System.out.println("Successfully sorted the ride records of [" + rideName + "]!");
    }

    // RunOneCycle() for Part 5: still occupying space
    @Override
    public void runOneCycle() {
        System.out.println("\n=== Start running the [" + rideName + "] cycle ===");

        // 1. Check if there is an operator (if there is no operator, it cannot run)
        if (this.operator == null) {
            System.out.println("Error: [" + rideName + "] No operator assigned, unable to run cycle!");
            return;
        }

        // 2. Check if there are any tourists in the queue (if there are no tourists, it cannot run)
        if (waitingLine.isEmpty()) {
            System.out.println("Error: [" + rideName + "] Waiting queue is empty, unable to run cycle!");
            return;
        }

        // 3. Determine the number of tourists to be collected in this cycle
        int takeCount = Math.min(maxRider, waitingLine.size());
        System.out.println("Passenger capacity for this cycle:" + maxRider + " people, actual queue size:" + waitingLine.size() + "people, " + takeCount + " people will be selected.");

        // 4. Retrieve tourists from the queue and add them to the ride record
        for (int i = 0; i < takeCount; i++) {
            Visitor visitor = waitingLine.poll(); // Remove the first tourist from the team
            if (visitor != null) {
                rideHistory.add(visitor); // Join Record
                System.out.println("Tourist [" + visitor. getName() + "] has taken [" + rideName + "]");
            }
        }

        // 5. Number of update cycles
        this.incrementCycles();
        System.out.println("[" + rideName + "]cycle run completed! Current total number of cycles:" + this.numOfCycles);
    }

    // Original toString(): Add the size of the queue and records
    @Override
    public String toString() {
        return "Ride{" +
                "rideId='" + rideId + '\'' +
                ", rideName='" + rideName + '\'' +
                ", maxRider=" + maxRider +
                ", operator=" + operator +
                ", numOfCycles=" + numOfCycles +
                ", waitingQueueSize=" + waitingLine.size() +
                ", numberOfPassengersRecorded=" + rideHistory.size() +
                '}';
    }

    //Implement Part 6: Export ride records to CSV file
    public void exportRideHistory(String filePath) {
        System.out.println("\n=== Start exporting [" + rideName + "] ride records to file:" + filePath + " ===");
        // 1. Check if the record is empty
        if (rideHistory.isEmpty()) {
            System.out.println("Error: The ride record is empty, no need to export!");
            return;
        }

        // 2. Use try with resources: automatically close the stream
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(filePath))) {
            // 3. Write CSV header
            writer.write("personId,name,age,visitorId,membershipType");
            writer.newLine();

            // 4. Traverse ride records and write data for each row
            Iterator<Visitor> iterator = rideHistory.iterator();
            while (iterator.hasNext()) {
                Visitor visitor = iterator.next();
                // Splicing CSV rows: fields separated by commas, handling possible null values
                String line = String.join(",",
                        visitor.getPersonId() == null ? "" : visitor.getPersonId(),
                        visitor.getName() == null ? "" : visitor.getName(),
                        String.valueOf(visitor.getAge()),
                        visitor.getVisitorId() == null ? "" : visitor.getVisitorId(),
                        visitor.getMembershipType() == null ? "" : visitor.getMembershipType()
                );
                writer.write(line);
                writer.newLine();
            }

            System.out.println("Export successful! A total of" + rideHistory.size() + "records were exported.");
        } catch (FileNotFoundException e) {
            System.out.println("Error: The file path does not exist!" + e.getMessage());
        } catch (IOException e) {
            System.out.println("Error: IO exception, export failed!" + e.getMessage());
        } catch (Exception e) {
            System.out.println("Error: Unknown exception, export failed!" + e.getMessage());
        }
    }

    // Implementing Part 7: Importing Ride Records from CSV Files
    public void importRideHistory(String filePath) {
        System.out.println("\n=== Start importing ride records from file: " + filePath + " to [" + rideName + "] ===");
        File file = new File(filePath);
        // 1. Check if the file exists
        if (!file.exists()) {
            System.out.println("Error: The file does not exist!");
            return;
        }

        // 2. Use try with resources: automatically close the stream
        int importCount = 0; // Number of successfully imported records
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            String line;
            // 3. Skip header: Read the first line and determine if it is a header
            line = reader.readLine();
            if (line == null) {
                System.out.println("Error: The file is empty!");
                return;
            }
            // Check if the first line is a header, if so skip it
            if (line.contains("personId")) {
                System.out.println("Skip CSV header:" + line);
            } else {
                // If the first row is not the header, process the data in that row
                Visitor visitor = parseCsvLineToVisitor(line);
                if (visitor != null) {
                    rideHistory.add(visitor);
                    importCount++;
                }
            }

            // 4. Process remaining row data
            while ((line = reader.readLine()) != null) {
                Visitor visitor = parseCsvLineToVisitor(line);
                if (visitor != null) {
                    rideHistory.add(visitor);
                    importCount++;
                }
            }

            System.out.println("Import completed! A total of" + importCount + "records were imported, and the total number of passengers in the current ride record is:" + rideHistory.size());
        } catch (FileNotFoundException e) {
            System.out.println("Error: File not found!" + e.getMessage());
        } catch (IOException e) {
            System.out.println("Error: IO exception, import failed!" + e.getMessage());
        } catch (Exception e) {
            System.out.println("Error: Unknown exception, import failed!" + e.getMessage());
        }
    }

    private Visitor parseCsvLineToVisitor(String line) {
        try {
            // Split CSV rows (separated by commas)
            String[] fields = line.split(",");
            // Check if the number of fields is correct
            if (fields.length < 5) {
                System.out.println("Warning: CSV row format error (insufficient fields), skip this row:" + line);
                return null;
            }

            // Extract fields and convert types
            String personId = fields[0].trim().isEmpty() ? "unknown" : fields[0].trim();
            String name = fields[1].trim().isEmpty() ? "unknown tourist" : fields[1].trim();
            int age = fields[2].trim().isEmpty() ? 0 : Integer.parseInt(fields[2].trim());
            String visitorId = fields[3].trim().isEmpty() ? "unknown" : fields[3].trim();
            String membershipType = fields[4].trim().isEmpty() ? "non-member" : fields[4].trim();

            // Create and return Visitor object
            return new Visitor(personId, name, age, visitorId, membershipType);
        } catch (NumberFormatException e) {
            System.out.println("Warning: Age format error, skip this line:" + line + ", Error:" + e.getMessage());
            return null;
        } catch (Exception e) {
            System.out.println("Warning: Failed to parse CSV row, skip this row:" + line + ", Error:" + e.getMessage());
            return null;
        }
    }
}
